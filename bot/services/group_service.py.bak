"""
# ============================================================================ #
# Dosya: group_service.py
# Yol: /Users/siyahkare/code/telegram-bot/bot/services/group_service.py
# Ä°ÅŸlev: Grup mesajlarÄ± ve grup yÃ¶netimi iÃ§in servis.
#
# Â© 2025 SiyahKare YazÄ±lÄ±m - TÃ¼m HaklarÄ± SaklÄ±dÄ±r
# ============================================================================ #
"""

import asyncio
import logging
import random
import traceback
import os
import json
from datetime import datetime, timedelta
from typing import Dict, Any, List, Optional, Union
from telethon import errors
from telethon.errors import FloodWaitError, ChannelPrivateError, ChatWriteForbiddenError, ChatAdminRequiredError, ChatGuestSendForbiddenError, UserBannedInChannelError, ChatRestrictedError
from pathlib import Path
import functools
from dotenv import load_dotenv
from bot.utils.adaptive_rate_limiter import AdaptiveRateLimiter
import aiosqlite
import time

from bot.services.base_service import BaseService
from bot.utils.progress_manager import ProgressManager

logger = logging.getLogger(__name__)

class GroupService(BaseService):
    """
    Grup mesajlarÄ± ve grup yÃ¶netimi iÃ§in servis.
    
    Bu servis, grup mesajlarÄ± gÃ¶ndermek, grup Ã¼ye bilgilerini yÃ¶netmek
    ve grup aktivitelerini izlemek iÃ§in kullanÄ±lÄ±r.
    
    Attributes:
        messages: Gruplara gÃ¶nderilecek mesaj ÅŸablonlarÄ±
        active_groups: Aktif grup bilgilerinin tutulduÄŸu sÃ¶zlÃ¼k
        error_groups: Hata veren gruplarÄ±n bilgilerinin tutulduÄŸu sÃ¶zlÃ¼k
        last_message_times: Son mesaj gÃ¶nderim zamanlarÄ±nÄ±n tutulduÄŸu sÃ¶zlÃ¼k
    """
    
    def __init__(self, client, config, db, stop_event=None):
        """
        GroupService sÄ±nÄ±fÄ±nÄ±n baÅŸlatÄ±cÄ±sÄ±.
        
        Args:
            client: Telegram istemcisi
            config: YapÄ±landÄ±rma nesnesi
            db: VeritabanÄ± nesnesi
            stop_event: Durdurma sinyali iÃ§in event nesnesi
        """
        super().__init__("group", client, config, db, stop_event)
        
        # Mesaj ÅŸablonlarÄ±nÄ± yÃ¼kle
        self.message_templates = []
        self._load_message_templates()
        
        # Grup mesaj gÃ¶nderme izleme
        self.last_message_times = {}
        
        # Ä°statistikler
        self.stats = {
            'total_sent': 0,
            'groups_discovered': 0,
            'last_message_time': None
        }
        
        # DiÄŸer baÅŸlatma kodlarÄ±...
        self.target_groups = []
        self.error_groups = []
        self.error_groups_set = set()
        self.sent_count = 0
        self.total_sent = 0
        
        # .env'den admin gruplarÄ±nÄ± yÃ¼kle
        self.admin_groups = self._load_admin_groups()
        
        # Stats deÄŸiÅŸkenini ekle (eksik olan buydu)
        self.stats.update({
            'messages_sent': 0,
            'messages_failed': 0,
            'total_groups': 0
        })
        
        # Grup yÃ¶netimi
        self.active_groups = {}
        self.error_reasons = {}
        self.group_activity_levels = {}
        
        # YapÄ±landÄ±rma ayarlarÄ±
        self.batch_size = 3
        self.batch_interval = 3
        self.min_message_interval = 60
        self.max_retries = 5
        self.prioritize_active = True
        
        # Durum yÃ¶netimi
        self.is_paused = False
        self.shutdown_event = asyncio.Event()
        
        # Rich konsol
        from rich.console import Console
        self.console = Console()
        
        # Config'den ayarlarÄ± yÃ¼kle (varsa)
        if hasattr(config, 'group_messaging'):
            group_config = config.group_messaging
            
            if hasattr(group_config, 'batch_size'):
                self.batch_size = group_config.batch_size
                
            if hasattr(group_config, 'batch_interval'):
                self.batch_interval = group_config.batch_interval
                
            if hasattr(group_config, 'min_message_interval'):
                self.min_message_interval = group_config.min_message_interval
                
            if hasattr(group_config, 'max_retries'):
                self.max_retries = group_config.max_retries
                
            if hasattr(group_config, 'prioritize_active'):
                self.prioritize_active = group_config.prioritize_active
                
        # DiÄŸer servislere referans
        self.services = {}
        
        # HÄ±z sÄ±nÄ±rlayÄ±cÄ±yÄ± yapÄ±landÄ±r
        self._setup_rate_limiter()
        
        # Grup aktivite izleme sistemi
        self.group_activity = {}  # grup_id -> aktivite sayacÄ±
        self.message_intervals = {}  # grup_id -> gÃ¶nderim aralÄ±ÄŸÄ± (saniye)
        
        # VarsayÄ±lan mesaj aralÄ±klarÄ± (saniye cinsinden)
        self.high_activity_interval = 300  # 5 dk (aktif gruplar)
        self.medium_activity_interval = 600  # 10 dk (orta aktiviteli gruplar)
        self.low_activity_interval = 1200  # 20 dk (dÃ¼ÅŸÃ¼k aktiviteli gruplar)
                
    def set_services(self, services):
        """DiÄŸer servislere referanslarÄ± ayarlar."""
        self.services = services
        logger.debug(f"{self.name} servisi diÄŸer servislere baÄŸlandÄ±")
        
        # Admin grup ID'lerini de baÅŸlangÄ±Ã§ta belirlemeye Ã§alÄ±ÅŸ
        self.admin_groups_ids = set()
        self.target_groups_ids = set()
        
        # GruplarÄ± yÃ¼kle ve ID'leri belirle
        if 'dm' in self.services and hasattr(self.services['dm'], 'get_groups'):
            try:
                # DM servisinden ID'leri Ã§ekmeye Ã§alÄ±ÅŸ
                asyncio.create_task(self._pre_load_group_ids())
            except Exception as e:
                logger.error(f"Grup ID'leri Ã¶nden yÃ¼klerken hata: {str(e)}")

    async def _pre_load_group_ids(self):
        """Grup ID'lerini belirlemeye Ã§alÄ±ÅŸÄ±r"""
        try:
            if 'dm' in self.services and hasattr(self.services['dm'], 'get_groups'):
                groups = await self.services['dm'].get_groups()
                
                for group in groups:
                    group_id = group.get('chat_id') or group.get('id')
                    group_title = group.get('title', '').lower()
                    group_username = group.get('username', '').lower()
                    
                    # Admin grup mu?
                    for admin_name in self.admin_groups:
                        if (group_username and admin_name in group_username) or \
                           (admin_name in group_title):
                            self.admin_groups_ids.add(group_id)
                            break
                    
                    # Target grup mu?
                    for target_name in self.target_groups:
                        if (group_username and target_name in group_username) or \
                           (target_name in group_title):
                            self.target_groups_ids.add(group_id)
                            break
                            
                logger.info(f"Ã–nden yÃ¼klenen grup ID'leri: {len(self.admin_groups_ids)} admin, {len(self.target_groups_ids)} target")
        except Exception as e:
            logger.error(f"Grup ID'lerini Ã¶nden yÃ¼kleme hatasÄ±: {str(e)}")
        
    async def initialize(self) -> bool:
        """GroupService servisini baÅŸlatÄ±r."""
        # Temel servisi baÅŸlat
        await super().initialize()
        
        # Bot modu kontrolÃ¼nÃ¼ kaldÄ±r
        self._can_use_dialogs = True
        self._can_discover_groups = True
        
        # Grup kategorileri ve aralÄ±k tanÄ±mlarÄ± (dakika cinsinden)
        self.admin_group_interval = 2.5  # Admin gruplarÄ±: 2-3 dk
        self.target_group_interval = 6.5  # Target gruplar: 6-7 dk
        
        # Aktivite bazlÄ± sÄ±klÄ±k (dakika)
        self.high_activity_interval = 5    # YoÄŸun gruplar: 5 dk
        self.medium_activity_interval = 10  # Orta yoÄŸunlukta: 10 dk
        self.low_activity_interval = 15     # Seyrek gruplar: 15 dk
        self.flood_activity_interval = 1    # Flood akÄ±ÅŸlÄ± gruplar: 1 dk
        
        # Grup listeleri yÃ¼kleme
        self.admin_groups = set()
        self.target_groups = set()
        
        # Admin/Target gruplarÄ± .env'den yÃ¼kle
        admin_groups_str = os.getenv("ADMIN_GROUPS", "")
        target_groups_str = os.getenv("TARGET_GROUPS", "")
        
        for group in admin_groups_str.split(','):
            if group.strip():
                self.admin_groups.add(group.strip().lower())
                
        for group in target_groups_str.split(','):
            if group.strip():
                self.target_groups.add(group.strip().lower())
        
        logger.info(f"Admin gruplarÄ± yÃ¼klendi: {len(self.admin_groups)} grup")
        logger.info(f"Target gruplar yÃ¼klendi: {len(self.target_groups)} grup")
        
        # Grup aktivite analizÃ¶rÃ¼ baÅŸlat
        self.activity_analyzer = self._setup_activity_analyzer()
        
        return True

    def _setup_activity_analyzer(self):
        """Grup aktivite analizÃ¶rÃ¼nÃ¼ hazÄ±rlar"""
        return {
            'group_history': {},       # grup_id -> son mesajlar
            'message_rates': {},       # grup_id -> mesaj/dakika oranÄ±
            'last_analysis_time': {},  # grup_id -> son analiz zamanÄ±
            'prime_time_groups': set() # prime time'da olan gruplar
        }

    def _setup_rate_limiter(self):
        """HÄ±z sÄ±nÄ±rlayÄ±cÄ±yÄ± yapÄ±landÄ±rÄ±r."""
        self.rate_limiter = AdaptiveRateLimiter(
            initial_rate=0.05,  # Saniyede 0.05 istek (20 saniyede 1 istek)
            period=60,          # 60 saniyelik periyot
            error_backoff=2.0,  # Hata durumunda 2x yavaÅŸlama
            max_jitter=5        # Maksimum 5 saniyelik rastgele gecikme
        )
        
        # Ä°statistikler
        self.message_send_stats = {
            'rate_limit_hits': 0,
            'total_waits': 0,
            'flood_waits': 0
        }
        
        logger.debug(f"Grup mesaj rate limiter baÅŸlatÄ±ldÄ±: {0.05}/sn")

    def _load_message_templates(self):
        """Mesaj ÅŸablonlarÄ±nÄ± yÃ¼kler."""
        
        # Ã–nce klasik yolu dene, sonra alternatif yollarÄ± kontrol et
        template_paths = [
            'data/messages.json',
            './data/messages.json',
            '../data/messages.json',
            'data/templates.json',
            './data/templates.json',
            '../data/templates.json'
        ]
        
        loaded = False
        
        # DÃ¼zenli mesaj ÅŸablonlarÄ±
        for path_str in template_paths:
            path = Path(path_str)
            if path.exists():
                try:
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                        
                        # FarklÄ± ÅŸablon yapÄ±larÄ± iÃ§in destek
                        if isinstance(data, list):
                            self.message_templates = data
                        elif isinstance(data, dict) and "messages" in data:
                            self.message_templates = data["messages"]
                        else:
                            # Mesaj kategorilerini yÃ¼kle
                            self.message_templates = []
                            for key, value in data.items():
                                if key == "regular" or key == "default":
                                    self.message_templates = value
                                elif key == "announcements":
                                    self.announcement_templates = value
                                elif key == "promotions" or key == "promos":
                                    self.promotion_templates = value
                                    
                        logger.info(f"Mesaj ÅŸablonlarÄ± baÅŸarÄ±yla yÃ¼klendi: {path_str} ({len(self.message_templates)} ÅŸablon)")
                        loaded = True
                        break
                except Exception as e:
                    logger.warning(f"Mesaj ÅŸablonlarÄ± yÃ¼klenirken hata: {path_str} - {str(e)}")
        
        # Announcement ve promo ÅŸablonlarÄ± iÃ§in ayrÄ± dosyalara bakma
        announcement_paths = ['data/announcements.json', './data/announcements.json']
        for ann_path in announcement_paths:
            try:
                announcement_path = Path(ann_path)
                if announcement_path.exists():
                    with open(announcement_path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                        
                        # TÃ¼m duyuru mesajlarÄ±nÄ± dÃ¼zleÅŸtir
                        self.announcement_templates = []
                        
                        # "own_groups" kategorisinden duyurularÄ± al
                        if "own_groups" in data:
                            for category, messages in data["own_groups"].items():
                                self.announcement_templates.extend(messages)
                        
                        logger.info(f"Duyuru ÅŸablonlarÄ± baÅŸarÄ±yla yÃ¼klendi: {ann_path} ({len(self.announcement_templates)} ÅŸablon)")
                        break
            except Exception as e:
                logger.warning(f"Duyuru ÅŸablonlarÄ± yÃ¼klenirken hata: {ann_path} - {str(e)}")
        
        # Kampanya ÅŸablonlarÄ±nÄ± yÃ¼kle
        promo_paths = ['data/promos.json', './data/promos.json', 'data/campaigns.json']
        for promo_path_str in promo_paths:
            try:
                promo_path = Path(promo_path_str)
                if promo_path.exists():
                    with open(promo_path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                        
                        # TÃ¼m kampanya mesajlarÄ±nÄ± dÃ¼zleÅŸtir
                        self.promotion_templates = []
                        
                        # Kampanya kategorilerinden mesajlarÄ± al
                        # Ä°Ã§ iÃ§e yapÄ±larÄ± destekle
                        if "templates" in data:
                            for category, messages in data["templates"].items():
                                if isinstance(messages, list):
                                    self.promotion_templates.extend(messages)
                        
                        if "campaign_templates" in data:
                            for category, messages in data["campaign_templates"].items():
                                if isinstance(messages, list):
                                    self.promotion_templates.extend(messages)
                        
                        # DoÄŸrudan mesajlar da olabilir
                        for category, messages in data.items():
                            if category not in ["templates", "campaign_templates"] and isinstance(messages, list):
                                self.promotion_templates.extend(messages)
                        
                        logger.info(f"Kampanya ÅŸablonlarÄ± baÅŸarÄ±yla yÃ¼klendi: {promo_path_str} ({len(self.promotion_templates)} ÅŸablon)")
                        break
            except Exception as e:
                logger.warning(f"Kampanya ÅŸablonlarÄ± yÃ¼klenirken hata: {promo_path_str} - {str(e)}")
        
        # VarsayÄ±lan ÅŸablonlarÄ± kontrolÃ¼
        if not hasattr(self, 'message_templates') or not self.message_templates:
            self.message_templates = [
                "Selam grup, nasÄ±lsÄ±nÄ±z?", 
                "BugÃ¼n keyifler nasÄ±l?", 
                "GÃ¼zel bir gÃ¼n deÄŸil mi?",
                "ArkadaÅŸlar merhaba, bugÃ¼n neler yapÄ±yorsunuz?",
                "Sohbete katÄ±lmak isteyen var mÄ±?"
            ]
            logger.warning("Mesaj ÅŸablonlarÄ± yÃ¼klenemedi! VarsayÄ±lan mesajlar kullanÄ±lÄ±yor!")
            
        # Duyuru ÅŸablonlarÄ±nÄ± kontrol et
        if not hasattr(self, 'announcement_templates') or not self.announcement_templates:
            self.announcement_templates = [
                "ğŸ“¢ DUYURU: GruplarÄ±mÄ±z bÃ¼yÃ¼meye devam ediyor!", 
                "ğŸ“¢ Yeni Ã¶zelliklerimizi keÅŸfetmek ister misiniz?",
                "ğŸ“¢ Bu hafta yeni etkinliklerimiz var, katÄ±lÄ±n!"
            ]
            logger.warning("Duyuru ÅŸablonlarÄ± yÃ¼klenemedi! VarsayÄ±lan duyurular kullanÄ±lÄ±yor!")
            
        # Kampanya ÅŸablonlarÄ±nÄ± kontrol et
        if not hasattr(self, 'promotion_templates') or not self.promotion_templates:
            self.promotion_templates = [
                "ğŸ”¥ Ã–zel kampanya: Bu fÄ±rsatÄ± kaÃ§Ä±rmayÄ±n!", 
                "ğŸ’¥ SÄ±nÄ±rlÄ± sÃ¼re teklifi: Hemen bizimle iletiÅŸime geÃ§in!",
                "ğŸ¯ Size Ã¶zel indirim: Detaylar iÃ§in mesaj atÄ±n!"
            ]
            logger.warning("Kampanya ÅŸablonlarÄ± yÃ¼klenemedi! VarsayÄ±lan kampanyalar kullanÄ±lÄ±yor!")

    def _register_event_handlers(self):
        """
        Grup mention ve reply yanÄ±tlarÄ± iÃ§in event handler'larÄ± kaydeder.
        """
        from telethon import events
        
        # Self mention handler (kullanÄ±cÄ± bot'u etiketlediÄŸinde)
        @self.client.on(events.NewMessage(incoming=True, pattern=r'@\w+'))
        async def handle_mention(event):
            try:
                # Bot'un kendi kullanÄ±cÄ± adÄ±nÄ± al
                me = await self.client.get_me()
                bot_username = me.username
                
                # Mesaj iÃ§eriÄŸi
                message_text = event.message.text
                
                # Bot'a mention yapÄ±ldÄ± mÄ± kontrol et
                if f'@{bot_username}' in message_text.lower():
                    logger.info(f"Bot mention edildi: {message_text}")
                    
                    # YanÄ±t ver
                    await self._reply_to_mention(event)
                    
            except Exception as e:
                logger.error(f"Mention handler hatasÄ±: {str(e)}")
        
        # Reply handler (kullanÄ±cÄ± bot'un mesajÄ±na yanÄ±t verdiÄŸinde)
        @self.client.on(events.NewMessage(incoming=True))
        async def handle_reply(event):
            try:
                # Bir reply mesajÄ± mÄ±?
                if event.message.reply_to and event.message.reply_to.reply_to_msg_id:
                    # Reply edilen mesajÄ± al
                    replied_to = await event.message.get_reply_message()
                    
                    if replied_to:
                        # Bot'un kendi kullanÄ±cÄ± adÄ±nÄ± al
                        me = await self.client.get_me()
                        
                        # Bot'un mesajÄ±na mÄ± yanÄ±t verildi?
                        if replied_to.sender_id == me.id:
                            logger.info(f"Bot'un mesajÄ±na yanÄ±t verildi: {event.message.text}")
                            
                            # YanÄ±t ver
                            await self._reply_to_message(event)
                            
            except Exception as e:
                logger.error(f"Reply handler hatasÄ±: {str(e)}")
        
        # Grup mesajlarÄ±nÄ± takip etmek iÃ§in dinleyici ekle
        @self.client.on(events.NewMessage)
        async def track_group_messages(event):
            try:
                # Sadece grup mesajlarÄ±nÄ± izle (Ã¶zel mesajlarÄ± deÄŸil)
                if hasattr(event.chat, 'id') and not event.is_private and event.chat_id < 0:
                    chat_id = event.chat_id
                    
                    # Grup aktivite analizÃ¶rÃ¼ne mesajÄ± kaydet
                    if chat_id not in self.activity_analyzer['group_history']:
                        self.activity_analyzer['group_history'][chat_id] = []
                        
                    # Mesaj bilgilerini kaydet
                    self.activity_analyzer['group_history'][chat_id].append({
                        'time': datetime.now(),
                        'sender_id': event.sender_id,
                        'message_length': len(event.message.text) if event.message.text else 0
                    })
                    
                    # Maks 100 mesaj tut grup baÅŸÄ±na
                    if len(self.activity_analyzer['group_history'][chat_id]) > 100:
                        self.activity_analyzer['group_history'][chat_id] = \
                            self.activity_analyzer['group_history'][chat_id][-100:]
            except Exception as e:
                logger.debug(f"Grup mesaj izleme hatasÄ±: {str(e)}")
                
        # Event handler'larÄ± kaydet
        self.mention_handler = handle_mention
        self.reply_handler = handle_reply
        self.message_tracker = track_group_messages
        
        logger.info("Grup event handler'larÄ± baÅŸarÄ±yla kaydedildi")

    async def _reply_to_mention(self, event):
        """
        Bot mention edildiÄŸinde yanÄ±t verir.
        """
        try:
            # YanÄ±t mesajÄ±nÄ± hazÄ±rla
            reply_texts = [
                "Merhaba! Beni etiketlediniz. Size nasÄ±l yardÄ±mcÄ± olabilirim?",
                "Selam! NasÄ±l yardÄ±mcÄ± olabilirim?",
                "Merhaba! Grubumuzla ilgili sorularÄ±nÄ±z iÃ§in Ã¶zel mesaj atabilirsiniz."
            ]
            reply_text = random.choice(reply_texts)
            
            # YanÄ±t gÃ¶nder
            await event.reply(reply_text)
            
            logger.info(f"Mention'a yanÄ±t verildi: {reply_text}")
            
        except Exception as e:
            logger.error(f"Mention yanÄ±tlama hatasÄ±: {str(e)}")

    async def _reply_to_message(self, event):
        """
        Bot'un mesajÄ±na yanÄ±t verildiÄŸinde Ã§alÄ±ÅŸÄ±r.
        """
        try:
            # YanÄ±t mesajÄ±nÄ± hazÄ±rla
            reply_texts = [
                "MesajÄ±ma yanÄ±t verdiÄŸiniz iÃ§in teÅŸekkÃ¼r ederim!",
                "Evet, size nasÄ±l yardÄ±mcÄ± olabilirim?",
                "DiÄŸer sorularÄ±nÄ±z iÃ§in Ã¶zel mesaj atabilirsiniz."
            ]
            reply_text = random.choice(reply_texts)
            
            # YanÄ±t gÃ¶nder
            await event.reply(reply_text)
            
            logger.info(f"Reply'a yanÄ±t verildi: {reply_text}")
            
        except Exception as e:
            logger.error(f"Reply yanÄ±tlama hatasÄ±: {str(e)}")
        
    async def start(self) -> bool:
        """
        Servisi baÅŸlatÄ±r ve gerekli kaynaklarÄ± hazÄ±rlar.
        
        Returns:
            bool: BaÅŸarÄ±lÄ± ise True
        """
        self.running = True
        self.is_paused = False
        
        # Aktif grup sayÄ±sÄ±nÄ± kontrol et
        if not self.active_groups:
            logger.warning("Aktif grup bulunamadÄ±. Grup keÅŸfi yapÄ±lacak.")
            await self.discover_groups()
            
        # HatalarÄ± temizle
        self.error_groups_set.clear()
        self.error_count = 0
        
        logger.info("Grup mesaj servisi baÅŸlatÄ±ldÄ±")
        return True
    
    async def stop(self) -> None:
        """
        Servisi gÃ¼venli bir ÅŸekilde durdurur.
        
        Returns:
            None
        """
        logger.info("Grup servisi durduruluyor...")
        self.running = False
        self.shutdown_event.set()
        
        await super().stop()
        logger.info("Grup servisi durduruldu")
        
    async def pause(self) -> None:
        """
        Servisi geÃ§ici olarak duraklatÄ±r.
        
        Returns:
            None
        """
        if not self.is_paused:
            self.is_paused = True
            logger.info("Grup servisi duraklatÄ±ldÄ±")
            
    async def resume(self) -> None:
        """
        DuraklatÄ±lmÄ±ÅŸ servisi devam ettirir.
        
        Returns:
            None
        """
        if self.is_paused:
            self.is_paused = False
            logger.info("Grup servisi devam ettiriliyor")
            
    async def run(self):
        """Servis ana Ã§alÄ±ÅŸma dÃ¶ngÃ¼sÃ¼"""
        logger.info("Grup servisi baÅŸlatÄ±lÄ±yor...")
        
        while self.running and not self.stop_event.is_set():
            try:
                # Yeni gruplarÄ± keÅŸfet (her 10 dakikada bir)
                if self._should_discover():
                    await self._periodic_discovery()
                    self.last_discovery = datetime.now()
                    
                # Gruplara mesaj gÃ¶nder (her Ã§evrimde)
                logger.info("Grup mesaj gÃ¶nderimi baÅŸlatÄ±lÄ±yor...")
                await self._send_messages_to_groups()
                
                # Grup aktivite metriklerini gÃ¼ncelle
                await self._update_group_activity_metrics()
                
                # KÄ±sa bekle ve tekrar kontrol et
                await asyncio.sleep(10)
                    
            except Exception as e:
                logger.error(f"Grup servisi dÃ¶ngÃ¼sÃ¼ hatasÄ±: {str(e)}")
                await asyncio.sleep(30)  # Hata durumunda daha uzun bekle

    async def _should_discover(self):
        """
        Grup keÅŸfi iÃ§in gerekli koÅŸullarÄ± kontrol eder.
        
        Returns:
            bool: KoÅŸullar saÄŸlanÄ±yorsa True, aksi halde False
        """
        # Ã–rnek koÅŸul: Her 10 dakikada bir keÅŸif yap
        return (datetime.now() - self.last_discovery).total_seconds() >= 600
            
    async def _periodic_discovery(self):
        """Periyodik grup keÅŸfi yapar"""
        try:
            # HATALI: Bir sÄ±nÄ±fÄ± fazla parametre ile baÅŸlatma
            # new_groups = SomeClass(param1, param2)  # Bu satÄ±rÄ± bulun
            
            # DOÄRU: Parametre sayÄ±sÄ±nÄ± azaltÄ±n veya sÄ±nÄ±fÄ± dÃ¼zeltin
            # Ya parametre sayÄ±sÄ±nÄ± azaltÄ±n:
            # new_groups = SomeClass(param1)
            
            # Ya da direkt discover_groups_aggressive() metodunu Ã§aÄŸÄ±rÄ±n:
            await self.discover_groups_aggressive()
            
            # 10 dakika bekle
            await asyncio.sleep(600)
        except Exception as e:
            logger.error(f"Periyodik keÅŸif hatasÄ±: {str(e)}")

    async def discover_groups_aggressive(self):
        """Agresif grup keÅŸfi - daha Ã§ok grup bul."""
        try:
            logger.info("Agresif grup keÅŸfi baÅŸlatÄ±lÄ±yor...")
            
            # Normal discover_groups metodunu Ã§aÄŸÄ±r
            discovered_groups = await self.discover_groups()
            
            # TÃ¼m gruplardan kullanÄ±cÄ± Ã§ekme iÅŸlemini baÅŸlat
            if discovered_groups:
                # GruplarÄ± uygun formata dÃ¶nÃ¼ÅŸtÃ¼r
                active_groups = []
                for group in discovered_groups:
                    # chat_id ve group_id tutarlÄ±lÄ±ÄŸÄ±nÄ± saÄŸla
                    chat_id = group.get('chat_id')
                    if not chat_id:
                        chat_id = group.get('group_id')
                    
                    if not chat_id:
                        logger.warning(f"Grup ID bulunamadÄ±: {group.get('title', 'Bilinmeyen Grup')}")
                        continue
                    
                    active_groups.append({
                        'group_id': chat_id,  # group_id olarak chat_id deÄŸerini kullan
                        'chat_id': chat_id,   # chat_id deÄŸerini de sakla
                        'title': group.get('title', 'Bilinmeyen Grup'),
                        'name': group.get('title', 'Bilinmeyen Grup')
                    })
                
                # KullanÄ±cÄ±larÄ± Ã§ek (arka planda)
                logger.info(f"Agresif keÅŸif: {len(active_groups)} aktif gruptan kullanÄ±cÄ± Ã§ekiliyor...")
                asyncio.create_task(self._extract_users_from_groups(active_groups))
            
            logger.info(f"Agresif grup keÅŸfi tamamlandÄ±: {len(discovered_groups)} grup bulundu")
            return discovered_groups
        except Exception as e:
            logger.error(f"Agresif grup keÅŸfi sÄ±rasÄ±nda hata: {str(e)}")
            return []

    def _load_admin_groups(self):
        """
        .env dosyasÄ±ndan admin gruplarÄ±nÄ± yÃ¼kler.
        
        Returns:
            List[str]: Admin grup adlarÄ±nÄ± iÃ§eren liste
        """
        import os
        from dotenv import load_dotenv
        
        # .env dosyasÄ±nÄ± yeniden oku (Ã¶nemli)
        load_dotenv()
        
        # ADMIN_GROUPS deÄŸiÅŸkenini al
        admin_groups_str = os.getenv("ADMIN_GROUPS", "")
        logger.info(f"ADMIN_GROUPS Ã§evre deÄŸiÅŸkeni: '{admin_groups_str}'")
        
        admin_groups = [group.strip() for group in admin_groups_str.split(",") if group.strip()]
        
        if admin_groups:
            logger.info(f".env dosyasÄ±ndan {len(admin_groups)} admin grup yÃ¼klendi: {', '.join(admin_groups)}")
        else:
            logger.warning("ADMIN_GROUPS Ã§evre deÄŸiÅŸkeni tanÄ±mlanmamÄ±ÅŸ veya boÅŸ")
            
        return admin_groups

    async def _get_active_groups(self) -> List[Dict[str, Any]]:
        """
        Aktif gruplarÄ± veritabanÄ±ndan getirir.
        
        Returns:
            List[Dict[str, Any]]: Aktif gruplarÄ±n listesi
        """
        logger.debug("Aktif gruplar getiriliyor...")
        
        query = """
        SELECT 
            chat_id, chat_name, join_date, 
            COALESCE(last_message_time, '0001-01-01 00:00:00') as last_message_time,
            last_message_type, 
            error_count, last_error, permanent_error,
            COALESCE(retry_after, '0001-01-01 00:00:00') as retry_after
        FROM groups 
        WHERE 
            (permanent_error IS NULL OR permanent_error != 1) AND
            (retry_after IS NULL OR retry_after < datetime('now'))
        ORDER BY last_message_time ASC
        LIMIT 50
        """
        
        try:
            rows = await self._run_async_db_method(self.db.fetchall, query)
            if not rows:
                logger.warning("VeritabanÄ±nda aktif grup bulunamadÄ±")
                return []
            
            now = datetime.now()
            active_groups = []
            
            for row in rows:
                # chat_id'nin None olup olmadÄ±ÄŸÄ±nÄ± kontrol et
                if row['chat_id'] is None:
                    logger.warning(f"VeritabanÄ±nda chat_id NULL olan grup bulundu: {row}")
                    continue
                    
                # chat_id'nin tip dÃ¶nÃ¼ÅŸÃ¼mÃ¼nÃ¼ gÃ¼venli bir ÅŸekilde yap
                try:
                    # String ise sayÄ±ya Ã§evir
                    if isinstance(row['chat_id'], str):
                        chat_id = int(row['chat_id'])
                    else:
                        chat_id = row['chat_id']
                except (ValueError, TypeError) as e:
                    logger.error(f"Grup chat_id'si dÃ¶nÃ¼ÅŸtÃ¼rÃ¼lemedi: {row['chat_id']} - Hata: {str(e)}")
                    continue
                    
                # DiÄŸer alanlarÄ± gÃ¼venli bir ÅŸekilde iÅŸle
                chat_name = row['chat_name'] or "Bilinmeyen Grup"
                last_message_time = row['last_message_time'] or "0001-01-01 00:00:00"
                error_count = row['error_count'] or 0
                
                try:
                    # Zaman bilgilerini kontrol et
                    last_msg_time = datetime.fromisoformat(last_message_time.replace('Z', '+00:00'))
                    time_since_last_message = (now - last_msg_time).total_seconds() / 3600  # saat cinsinden
                    
                    # 24 saatten uzun sÃ¼redir mesaj gÃ¶nderilmemiÅŸ gruplara Ã¶ncelik ver
                    priority = 5 if time_since_last_message > 24 else 1
                    
                    # Hata sayÄ±sÄ±na gÃ¶re Ã¶nceliÄŸi dÃ¼ÅŸÃ¼r
                    if error_count > 0:
                        priority -= min(error_count, 3)  # En fazla 3 puan dÃ¼ÅŸÃ¼r
                    
                    active_groups.append({
                        'chat_id': chat_id,
                        'chat_name': chat_name,
                        'priority': max(priority, 1),  # Minimum 1 Ã¶ncelik
                        'last_message_time': last_message_time,
                        'error_count': error_count
                    })
                    
                except (ValueError, TypeError) as e:
                    logger.error(f"Grup {chat_id} iÃ§in tarih bilgisi iÅŸlenemedi: {last_message_time} - Hata: {str(e)}")
                    # Yine de listeye ekle ama dÃ¼ÅŸÃ¼k Ã¶ncelikle
                    active_groups.append({
                        'chat_id': chat_id,
                        'chat_name': chat_name,
                        'priority': 1,  # DÃ¼ÅŸÃ¼k Ã¶ncelik
                        'last_message_time': "0001-01-01 00:00:00",
                        'error_count': error_count
                    })
            
            # Ã–nceliÄŸe gÃ¶re sÄ±rala
            active_groups.sort(key=lambda x: (-x['priority'], x['last_message_time']))
            
            logger.info(f"Toplam {len(active_groups)} aktif grup bulundu")
            return active_groups
            
        except Exception as e:
            logger.error(f"Aktif gruplar getirilirken hata oluÅŸtu: {str(e)}")
            return []

    async def _send_messages_to_groups(self):
        """
        Aktif gruplara dÃ¼zenli olarak mesaj gÃ¶nderir.
        """
        try:
            if not self.client or not self.client.is_connected():
                logger.error("Mesaj gÃ¶nderme iÅŸlemi baÅŸlatÄ±lamadÄ±: Ä°stemci baÄŸlÄ± deÄŸil")
                return
                
            # Bot durdurulmuÅŸ mu kontrol et
            if self.is_stopped:
                logger.debug("Bot durdurulduÄŸu iÃ§in mesaj gÃ¶nderme iÅŸlemi atlandÄ±")
                return

            active_groups = await self._get_active_groups()
            if not active_groups:
                logger.info("Mesaj gÃ¶nderilecek aktif grup bulunamadÄ±")
                return
            
            logger.info(f"Toplam {len(active_groups)} aktif gruba mesaj gÃ¶nderme iÅŸlemi baÅŸlatÄ±lÄ±yor")
            
            for group_data in active_groups:
                if self.is_stopped:
                    logger.warning("Bot durduruldu, mesaj gÃ¶nderme dÃ¶ngÃ¼sÃ¼ sonlandÄ±rÄ±lÄ±yor")
                    break
                    
                chat_id = group_data['chat_id']
                chat_name = group_data.get('chat_name', 'Bilinmeyen Grup')
                
                # Rate limiter kontrolÃ¼
                if hasattr(self, 'rate_limiter') and self.rate_limiter:
                    if not await self.rate_limiter.can_execute():
                        wait_time = await self.rate_limiter.get_wait_time()
                        logger.warning(f"Rate limit aÅŸÄ±ldÄ±, {wait_time} saniye bekleniyor")
                        await asyncio.sleep(wait_time)
                
                # Gruba mesaj gÃ¶ndermeyi dene
                try:
                    result = await self._send_message_to_group(chat_id)
                    
                    if result:
                        logger.info(f"Mesaj baÅŸarÄ±yla gÃ¶nderildi: {chat_name} (ID: {chat_id})")
                        if hasattr(self, 'rate_limiter') and self.rate_limiter:
                            await self.rate_limiter.mark_success()
                    else:
                        logger.warning(f"Mesaj gÃ¶nderme baÅŸarÄ±sÄ±z: {chat_name} (ID: {chat_id})")
                    
                    # Her mesaj arasÄ±nda biraz bekle
                    delay = random.uniform(5, 15)
                    logger.debug(f"Bir sonraki mesaj iÃ§in {delay:.2f} saniye bekleniyor")
                    await asyncio.sleep(delay)
                    
        except Exception as e:
                    logger.error(f"Gruba mesaj gÃ¶nderirken beklenmeyen hata: {chat_name} (ID: {chat_id}) - {str(e)}")
                    continue
                
        except Exception as e:
            logger.error(f"Gruplara mesaj gÃ¶nderme iÅŸlemi sÄ±rasÄ±nda genel hata: {str(e)}")

    async def _update_group_activity_metrics(self):
        """GruplarÄ±n aktivite metriklerini gÃ¼nceller"""
        try:
            logger.debug("Grup aktivite metrikleri gÃ¼ncelleniyor...")
            
            # GruplarÄ±n son mesajlarÄ±nÄ± kontrol et
            for group_id, history in self.activity_analyzer['group_history'].items():
                # Son 10 dakikalÄ±k mesajlarÄ± filtrele
                now = datetime.now()
                recent_messages = [msg for msg in history 
                                  if (now - msg['time']).total_seconds() < 600]
                
                # Mesaj sayÄ±sÄ±ndan oranÄ± hesapla
                if recent_messages:
                    # En eski mesaj ile en yeni mesaj arasÄ±ndaki sÃ¼re (dakika)
                    oldest = min(msg['time'] for msg in recent_messages)
                    newest = max(msg['time'] for msg in recent_messages)
                    duration_minutes = max(0.1, (newest - oldest).total_seconds() / 60)
                    
                    # Dakika baÅŸÄ±na mesaj sayÄ±sÄ±
                    rate = len(recent_messages) / duration_minutes
                    self.activity_analyzer['message_rates'][group_id] = rate
                    
                    # Prime time kontrolÃ¼
                    if rate > 30:
                        logger.info(f"Prime-time grup tespit edildi! ID: {group_id}, HÄ±z: {rate:.1f} mesaj/dakika")
                        self.activity_analyzer['prime_time_groups'].add(group_id)
                    elif group_id in self.activity_analyzer['prime_time_groups']:
                        self.activity_analyzer['prime_time_groups'].remove(group_id)
                
                # GeÃ§miÅŸ temizliÄŸi (10 dk'dan eski mesajlarÄ± sil)
                self.activity_analyzer['group_history'][group_id] = recent_messages
            
            logger.debug(f"Grup aktivite gÃ¼ncelleme tamamlandÄ±: {len(self.activity_analyzer['message_rates'])} grup")
            
        except Exception as e:
            logger.error(f"Grup aktivite gÃ¼ncelleme hatasÄ±: {str(e)}")

    async def _select_message_template(self, group_id, message_type='regular'):
        """
        Mesaj tÃ¼rÃ¼ne ve gruba gÃ¶re ÅŸablon seÃ§er ve formatlar.
        
        Args:
            group_id: Grup ID'si
            message_type: Mesaj tipi (regular, announcement, promotion, vb.)
            
        Returns:
            str: FormatlanmÄ±ÅŸ mesaj ÅŸablonu
        """
        try:
            templates = []
            
            # Mesaj tÃ¼rÃ¼ne gÃ¶re ÅŸablon seÃ§imi
            if message_type == "announcement" and hasattr(self, 'announcement_templates'):
                templates = self.announcement_templates
            elif message_type == "promotion" and hasattr(self, 'promotion_templates'):
                templates = self.promotion_templates
            else:
                templates = self.message_templates
                
            # Åablon yok ise varsayÄ±lan mesaj
            if not templates or len(templates) == 0:
                return "Merhaba! NasÄ±lsÄ±nÄ±z?"
                
            # Rastgele ÅŸablon seÃ§
            selected_template = random.choice(templates)
            
            # Grup bilgisini al (opsiyonel)
            group_info = None
            if hasattr(self.db, 'get_group_by_id'):
                group_info = await self._run_async_db_method(self.db.get_group_by_id, group_id)
                
            # Åablonu formatla
            # Gruba Ã¶zel deÄŸiÅŸkenleri ekle
            group_title = group_info.get('title', 'Grup') if group_info else 'Grup'
            
            # Basit formatlama dene
            try:
                message = selected_template.format(
                    group_name=group_title,
                    date=datetime.now().strftime("%d.%m.%Y"),
                    time=datetime.now().strftime("%H:%M")
                )
            except (KeyError, ValueError):
                # Format hatasÄ± durumunda ÅŸablonu olduÄŸu gibi kullan
                message = selected_template
                
            return message
            
        except Exception as e:
            logger.error(f"Mesaj ÅŸablonu seÃ§me hatasÄ±: {str(e)}")
            return "Merhaba! NasÄ±lsÄ±nÄ±z?"

    async def _select_message_by_type(self, message_type, group_id, group_title):
        """Mesaj tipine gÃ¶re ÅŸablon seÃ§er"""
        try:
            if message_type == "announcement" and hasattr(self, 'announcement_templates'):
                templates = self.announcement_templates
            elif message_type == "promotion" and hasattr(self, 'promotion_templates'):
                templates = self.promotion_templates
            else:
                templates = self.message_templates
                
            # Åablon seÃ§ ve formatla
            if templates:
                template = random.choice(templates)
                
                # Basit deÄŸiÅŸiklikler
                message = template.replace("{group_name}", group_title)
                message = message.replace("{time}", datetime.now().strftime("%H:%M"))
                message = message.replace("{date}", datetime.now().strftime("%d.%m.%Y"))
                
                return message
            else:
                # Åablon yoksa varsayÄ±lan mesaj
                return "Merhaba! NasÄ±lsÄ±nÄ±z?"
        except Exception as e:
            logger.error(f"Mesaj ÅŸablonu seÃ§me hatasÄ±: {str(e)}")
            return "Merhaba! NasÄ±lsÄ±nÄ±z?"

    async def analyze_group_safety(self, group_id, group_title=None):
        """
        Grubun gÃ¼venli olup olmadÄ±ÄŸÄ±nÄ± analiz eder
        
        Args:
            group_id: Grup ID
            group_title: Grup baÅŸlÄ±ÄŸÄ±
        
        Returns:
            dict: GÃ¼venlik analiz sonuÃ§larÄ±
        """
        try:
            # VeritabanÄ±ndan grup bilgisini al
            group_info = None
            if hasattr(self.db, 'get_group_by_id'):
                group_info = await self._run_async_db_method(self.db.get_group_by_id, group_id)
            
            # Grup baÅŸlÄ±ÄŸÄ±nÄ± al
            if not group_title:
                if group_info and 'title' in group_info:
                    group_title = group_info['title']
                else:
                    try:
                        entity = await self.client.get_entity(group_id)
                        group_title = entity.title
                    except:
                        group_title = "Bilinmeyen Grup"
            
            # BaÅŸlÄ±k filtreleri
            blacklist_keywords = [
                "porno", "sex", "adult", "nsfw", "xxx", "+18", "18+", 
                "viagra", "cialis", "porn", "casino", "bahis", "betting",
                "para kazanma", "ÅŸansÄ±nÄ± dene", "siirt"
            ]
            
            title_risk = 0
            for keyword in blacklist_keywords:
                if keyword in group_title.lower():
                    title_risk += 10
                    
            # DiÄŸer riskler
            admin_risk = 0
            content_risk = 0
            
            # Biraz bekleme sÃ¼resi oluÅŸtur
            # self._fetch_group_admins() metodunu kullan
            # Bu metodlarÄ±n implementasyonu burada olmadÄ±ÄŸÄ± iÃ§in sonuÃ§larÄ± varsayÄ±lan olarak dÃ¶ndÃ¼r
            
            return {
                'group_id': group_id,
                'group_title': group_title,
                'title_risk': title_risk,
                'admin_risk': admin_risk,
                'content_risk': content_risk,
                'total_risk': title_risk + admin_risk + content_risk,
                'is_safe': (title_risk + admin_risk + content_risk) < 30  # 30 puan altÄ±nda ise gÃ¼venli
            }
            
        except Exception as e:
            logger.error(f"Grup gÃ¼venlik analizi hatasÄ±: {str(e)}")
            return {
                'group_id': group_id,
                'error': str(e),
                'is_safe': False
            }

    async def _get_message_interval(self, group_id, group_title, group_username=None):
        """
        Belirli bir grup iÃ§in mesaj gÃ¶nderme aralÄ±ÄŸÄ±nÄ± hesaplar
        
        Args:
            group_id: Grup ID
            group_title: Grup baÅŸlÄ±ÄŸÄ±
            group_username: Grup kullanÄ±cÄ± adÄ± (opsiyonel)
        
        Returns:
            int: Mesaj gÃ¶nderme aralÄ±ÄŸÄ± (dakika)
        """
        try:
            # VarsayÄ±lan deÄŸer - orta seviye grup
            interval = self.medium_activity_interval  # 10 dakika
            
            # Grup tipine gÃ¶re deÄŸerlendir
        is_admin_group = False
            is_target_group = False
        
            # Admin grup kontrolÃ¼
            if hasattr(self, 'admin_groups_ids') and group_id in self.admin_groups_ids:
                is_admin_group = True
            else:
                # Ä°simle kontrol et
                for admin_name in getattr(self, 'admin_groups', []):
                    if (group_username and admin_name in group_username.lower()) or \
                       (admin_name in group_title.lower()):
                    is_admin_group = True
                    break
        
            # Target grup kontrolÃ¼
            if hasattr(self, 'target_groups_ids') and group_id in self.target_groups_ids:
                is_target_group = True
            else:
                # Ä°simle kontrol et
                for target_name in getattr(self, 'target_groups', []):
                    if (group_username and target_name in group_username.lower()) or \
                       (target_name in group_title.lower()):
                    is_target_group = True
                    break
        
            # Ã–ncelikle grup kategorisine gÃ¶re aralÄ±k belirle
            if is_admin_group:
                # Admin gruplara yÃ¼ksek Ã¶ncelikli mesaj
                interval = getattr(self, 'admin_group_interval', 2)  # 2 dakika
                logger.debug(f"Admin grup tespit edildi: {group_title}")
            elif is_target_group:
                # Hedef gruplara Ã¶zel sÄ±klÄ±k
                interval = getattr(self, 'target_group_interval', 5)  # 5 dakika
                logger.debug(f"Hedef grup tespit edildi: {group_title}")
            else:
                # Aktivite seviyesine gÃ¶re deÄŸerlendir
        activity_level = self._analyze_group_activity(group_id)
        
                if activity_level == "high":
                    interval = getattr(self, 'high_activity_interval', 5)  # 5 dakika
                elif activity_level == "medium":
                    interval = getattr(self, 'medium_activity_interval', 10)  # 10 dakika
                elif activity_level == "low":
                    interval = getattr(self, 'low_activity_interval', 15)  # 15 dakika
                elif activity_level == "flood":
                    interval = getattr(self, 'flood_activity_interval', 1)  # 1 dakika
                
                logger.debug(f"Aktivite seviyesi {activity_level} iÃ§in aralÄ±k: {interval} dk - {group_title}")
            
            # Rastgele varyasyon ekle (+/- %15)
            if interval > 3:  # KÃ¼Ã§Ã¼k aralÄ±klarda varyasyon ekleme
                variation = interval * 0.15
                interval += random.uniform(-variation, variation)
                # Alt sÄ±nÄ±r kontrolÃ¼
                interval = max(1, interval)
            
            return interval
            
        except Exception as e:
            logger.error(f"Mesaj aralÄ±ÄŸÄ± hesaplama hatasÄ±: {str(e)}")
            # Hata durumunda varsayÄ±lan aralÄ±ÄŸÄ± dÃ¶ndÃ¼r
            return self.medium_activity_interval  # 10 dakika varsayÄ±lan

    def _analyze_group_activity(self, group_id):
        """
        Grubun aktivite seviyesini analiz eder
        
        Args:
            group_id: Grup ID
        
        Returns:
            str: "high", "medium", "low" veya "flood"
        """
        try:
            # Grup aktivitesini incele
            if hasattr(self, 'activity_analyzer') and 'message_rates' in self.activity_analyzer:
                rate = self.activity_analyzer['message_rates'].get(group_id, 0)
                
                # 'flood' kontrolÃ¼ - Ã§ok yÃ¼ksek hÄ±zlÄ± gruplar iÃ§in Ã¶zel davranÄ±ÅŸ
                if rate > 50:  # Dakikada 50+ mesaj
                    return "flood"
                
                # Aktivite seviyelerini belirle
                if rate > 10:  # Dakikada 10+ mesaj
                    return "high"
                elif rate > 3:  # Dakikada 3-10 mesaj
                    return "medium"
        else:
                    return "low"
            
            # Activity analyzer yoksa varsayÄ±lan olarak orta seviye
            return "medium"
            
        except Exception as e:
            logger.error(f"Grup aktivite analizi hatasÄ±: {str(e)}")
            return "medium"  # VarsayÄ±lan deÄŸer

    async def discover_groups(self):
        """
        KullanÄ±cÄ±nÄ±n Ã¼ye olduÄŸu gruplarÄ± keÅŸfeder.
        
        Returns:
            List[Dict]: KeÅŸfedilen gruplarÄ±n bilgilerini iÃ§eren liste
        """
        try:
        discovered_groups = []
        
            # UserBot modu kontrolÃ¼
            if not self._can_use_dialogs:
                logger.warning("Bu hesap normal bot olduÄŸu iÃ§in grup keÅŸfi sÄ±nÄ±rlÄ±.")
                return []
            
            # Mevcut diyaloglarÄ± almaya Ã§alÄ±ÅŸ
            logger.info("Mevcut diyaloglar alÄ±nÄ±yor...")
            
            # DiyaloglarÄ± al (bÃ¼tÃ¼n gruplarÄ±)
            async for dialog in self.client.iter_dialogs():
                try:
                    # Sadece gruplarÄ± ve kanallarÄ± filtrele
                    if dialog.is_group or dialog.is_channel:
                        # Grubun veya kanalÄ±n detaylarÄ±nÄ± al
                        entity = dialog.entity
                        
                        try:
                            # BaÅŸlÄ±k kontrolÃ¼
                            title = entity.title if hasattr(entity, 'title') else "BaÅŸlÄ±ksÄ±z Grup"
                            
                            # ID kontrolÃ¼
                            chat_id = dialog.id
                            
                            # KullanÄ±cÄ± adÄ± kontrolÃ¼
                            username = entity.username if hasattr(entity, 'username') else None
                            
                            # Ãœye sayÄ±sÄ± (mÃ¼mkÃ¼nse)
                            try:
                                member_count = entity.participants_count if hasattr(entity, 'participants_count') else None
                            except:
                                member_count = None
                                
                            # Grup bilgilerini kaydet
                            group_info = {
                                'chat_id': chat_id,  # id -> chat_id olarak deÄŸiÅŸtirildi
                                'group_id': chat_id,  # group_id alanÄ±nÄ± da ekleyelim
                                'title': title,
                                'username': username,
                                'access_hash': entity.access_hash if hasattr(entity, 'access_hash') else None,
                                'member_count': member_count,
                                'discovery_time': datetime.now().isoformat()
                            }
                            
                                discovered_groups.append(group_info)
                                
                            # VeritabanÄ±na ekle (opsiyonel - fonksiyon varsa)
                                if hasattr(self.db, 'add_group'):
                                try:
                                    # Burada chat_id uygun ÅŸekilde geÃ§iriliyor
                                    response = await self._run_async_db_method(self.db.add_group, 
                                                                       chat_id, 
                                                                       title,
                                                                       username=username)
                                    if response:
                                        logger.debug(f"Grup veritabanÄ±na eklendi: {title} (#{chat_id})")
                                except Exception as db_error:
                                    logger.error(f"Grup DB ekleme hatasÄ±: {str(db_error)}")
                            # VeritabanÄ±na direkt SQL ile ekle
                            else:
                                try:
                                    # groups tablosuna SQL ile insert
                                    # chat_id'nin NULL olmamasÄ±nÄ± saÄŸlayalÄ±m
                                    query = """
                                    INSERT OR REPLACE INTO groups (chat_id, title, member_count, is_active) 
                                    VALUES (?, ?, ?, 1)
                                    """
                                    params = (chat_id, title, member_count or 0)
                                    
                                    await self._run_async_db_method(self.db.cursor.execute, query, params)
                                    await self._run_async_db_method(self.db.conn.commit)
                                    
                                    logger.debug(f"Grup SQL ile eklendi: {title} (#{chat_id})")
                                except Exception as sql_error:
                                    logger.error(f"Grup SQL ile eklenirken hata: {str(sql_error)}")
                            
                    except Exception as e:
                            logger.error(f"Grup iÅŸleme hatasÄ±: {str(e)}")
                            continue
                            
                except Exception as dialog_error:
                    logger.error(f"Dialog iÅŸleme hatasÄ±: {str(dialog_error)}")
                    continue
            
            # SonuÃ§larÄ± log
            logger.info(f"{len(discovered_groups)} grup keÅŸfedildi")
            
            # SÄ±nÄ±fÄ±n global deÄŸiÅŸkenini gÃ¼ncelle
            if hasattr(self, 'stats'):
            self.stats['groups_discovered'] = len(discovered_groups)
                
            # BaÅŸarÄ±lÄ± ise gÃ¼ncelle
            if hasattr(self, 'last_discovery_time'):
                self.last_discovery_time = datetime.now()
            
            return discovered_groups
            
        except Exception as e:
            logger.error(f"Grup keÅŸfi sÄ±rasÄ±nda hata: {str(e)}")
            return []

    async def _extract_users_from_groups(self, groups, progress=None, group_user_limit=500):
        """
        Belirtilen gruplardan kullanÄ±cÄ±larÄ± Ã§eker ve veritabanÄ±na kaydeder.
        
        Args:
            groups: KullanÄ±cÄ±larÄ± Ã§ekilecek gruplarÄ±n listesi
            progress: Rich Progress nesnesi
            group_user_limit: Her gruptan Ã§ekilecek maksimum kullanÄ±cÄ± sayÄ±sÄ±
        
        Returns:
            tuple: BaÅŸarÄ±lÄ± gruplarÄ±n sayÄ±sÄ±, hata olan gruplarÄ±n sayÄ±sÄ±
        """
        users_saved = []
        error_groups = 0
        extracted_users = 0
        success_groups = 0
        tasks = []

        try:
                for group in groups:
                # Ã–nce group_id, sonra chat_id, son olarak id alanlarÄ±nÄ± kontrol et
                group_id = group.get('group_id')
            
                # EÄŸer group_id yoksa chat_id'yi kontrol et
                if group_id is None:
                    group_id = group.get('chat_id')
            
                # EÄŸer chat_id de yoksa id'yi kontrol et (eski kod iÃ§in geriye uyumluluk)
                if group_id is None:
                group_id = group.get('id')
                
                # Grup ID kontrolÃ¼
                if not group_id:
                    group_title = group.get('title', 'Bilinmeyen Grup')
                    group_name = group.get('name', group_title)
                    logger.warning(f"GeÃ§ersiz grup ID: Grup adÄ±: {group_name} - {group}")
                    error_groups += 1
                    if progress:
                        progress.update(task, advance=1)
                    continue
                
                try:
                    # Grubu iÅŸle
                    group_title = group.get('title', group.get('name', 'Bilinmeyen Grup'))
                    logger.info(f"Grup iÅŸleniyor: {group_title} (ID: {group_id})")
                    users = await self._get_group_members_aggressive(group_id)
                    
                    # Telegram hatalarÄ±nÄ± kontrol et ve grubu gÃ¼ncelle
                    await self._update_group_success(group_id)
                    
                    # KullanÄ±cÄ±larÄ± veritabanÄ±na kaydet
                    saved_count = await self._save_users_from_group(users)
                    
                    # Ä°statistikleri gÃ¼ncelle
                    users_saved.append(saved_count)
                    extracted_users += len(users)
                    success_groups += 1
                    
                except ChatAdminRequiredError:
                    logger.warning(f"Admin yetkisi gerekli: {group_id}")
                    await self._update_group_error(group_id, "ChatAdminRequiredError", permanent=True)
                    error_groups += 1
                    
                except ChannelPrivateError:
                    logger.warning(f"Ã–zel kanal: {group_id}")
                    await self._update_group_error(group_id, "ChannelPrivateError", permanent=True)
                    error_groups += 1
                    
                except FloodWaitError as e:
                    wait_time = e.seconds
                    logger.warning(f"FloodWaitError: {wait_time} saniye beklenmeli - Grup: {group_id}")
                    await self._update_group_error(group_id, f"FloodWaitError: {wait_time}s", retry_after=wait_time)
                    if wait_time > 60:
                        # 1 dakikadan fazla beklemek gerekiyorsa, iÅŸlemi durdur
                        logger.error(f"FloodWaitError Ã§ok uzun ({wait_time}s), iÅŸlem durduruluyor")
                        raise
                    await asyncio.sleep(wait_time)
                    error_groups += 1
                    
                except Exception as e:
                    logger.error(f"Gruptan kullanÄ±cÄ± Ã§ekerken hata: {group_id} - {str(e)}")
                    await self._update_group_error(group_id, str(e))
                    error_groups += 1
                    
                finally:
                    # Ä°lerlemeyi gÃ¼ncelle
                    if progress:
                        progress.update(task, advance=1)
                    
            logger.info(f"Toplam Ã§ekilen kullanÄ±cÄ± sayÄ±sÄ±: {extracted_users}")
            logger.info(f"Kaydedilen kullanÄ±cÄ±lar: {sum(users_saved)}")
            
            return success_groups, error_groups
            
        except Exception as e:
            logger.error(f"Genel hata: {str(e)}")
            return success_groups, error_groups

    async def _get_group_members_aggressive(self, group_id):
        """
        Belirtilen gruptan kullanÄ±cÄ±larÄ± agresif ÅŸekilde Ã§eker.
        
        Args:
            group_id: KullanÄ±cÄ±larÄ±n Ã§ekileceÄŸi grup ID'si
            
        Returns:
            list: Gruptaki kullanÄ±cÄ±larÄ±n listesi
        """
        # Grup ID kontrolÃ¼
        if not group_id:
            logger.error("Grup ID None veya boÅŸ. KullanÄ±cÄ±lar Ã§ekilemiyor.")
            return []
            
        # String ise integer'a Ã§evir
        if isinstance(group_id, str) and group_id.isdigit():
            group_id = int(group_id)
        
        users = []
        offset = 0
        limit = 100
        all_participants = []
        
        try:
            # Grup entity'sini al
            try:
                entity = await self.client.get_entity(group_id)
                if not entity:
                    logger.warning(f"Grup entity bulunamadÄ±: {group_id}")
                    return []
                    
                # Entity tipini kontrol et
                if not hasattr(entity, 'title'):
                    logger.warning(f"GeÃ§ersiz grup entity tipi: {type(entity).__name__} (ID: {group_id})")
                    return []
                    
                logger.info(f"Grup kullanÄ±cÄ±larÄ± Ã§ekiliyor: '{entity.title}' (ID: {group_id})")
            except ValueError as ve:
                logger.error(f"GeÃ§ersiz grup ID: {group_id} - {str(ve)}")
                return []
            except TypeError as te:
                logger.error(f"Grup ID tipi hatasÄ±: {group_id} ({type(group_id)}) - {str(te)}")
                return []
            except Exception as e:
                logger.error(f"Grup entity alÄ±m hatasÄ±: {group_id} - {str(e)}")
                return []
            
            # FarklÄ± filtrelerle katÄ±lÄ±mcÄ± Ã§ekmeyi dene
            filter_types = [
                None,  # Filtre yok
                ChannelParticipantsRecent(),  # Son aktif olanlar
                ChannelParticipantsAdmins(),  # Adminler
            ]
            
            success = False
            for filter_type in filter_types:
                if success:
                    break
                    
                try:
                    filter_name = filter_type.__class__.__name__ if filter_type else "None"
                    logger.debug(f"Filtre deneniyor: {filter_name}")
                    
                    while True:
                        # Rate limit kontrolÃ¼
                        if not self.rate_limiter.can_execute():
                            wait_time = self.rate_limiter.get_wait_time()
                            logger.warning(f"Ãœye Ã§ekme iÃ§in rate limit aÅŸÄ±ldÄ±. {wait_time:.1f} saniye bekleniyor.")
                            await asyncio.sleep(wait_time)
                        
                        try:
                            participants = await self.client(GetParticipantsRequest(
                                channel=entity,
                                filter=filter_type,
                                offset=offset,
                                limit=limit,
                                hash=0
                            ))
                            
                            # BaÅŸarÄ±lÄ± istek
                            self.rate_limiter.mark_success()
                            
                            if not participants.users:
                                break
                                
                            all_participants.extend(participants.users)
                            offset += len(participants.users)
                            
                            # Yeterli sayÄ±da kullanÄ±cÄ± Ã§ekildiyse durabilir
                            if len(all_participants) >= 500:  # Maksimum kullanÄ±cÄ± sayÄ±sÄ±
                                logger.info(f"Maksimum kullanÄ±cÄ± sayÄ±sÄ±na ulaÅŸÄ±ldÄ±: {len(all_participants)}")
                                break
                                
                        except errors.FloodWaitError as flood_error:
                            wait_time = flood_error.seconds
                            logger.warning(f"FloodWaitError: {wait_time} saniye beklenmeli")
                            self.rate_limiter.register_error("FloodWaitError", wait_time)
                            await asyncio.sleep(min(wait_time, 60))  # Maksimum 60 saniye bekle
                            continue
        
        except Exception as e:
                            logger.error(f"KullanÄ±cÄ± Ã§ekme hatasÄ± ({filter_name}): {str(e)}")
                            self.rate_limiter.register_error("OtherError")
                            break
                    
                    if all_participants:
                        success = True
                        logger.info(f"Filtre ile baÅŸarÄ±lÄ± ÅŸekilde kullanÄ±cÄ±lar Ã§ekildi: {filter_name}")
                        
                except Exception as filter_error:
                    logger.warning(f"Filtre hatasÄ± ({filter_name}): {str(filter_error)}")
                    continue
            
            # Ã‡ekilen kullanÄ±cÄ±larÄ± iÅŸle
            for user in all_participants:
                if user.bot:
                    continue  # BotlarÄ± atla
                    
                # KullanÄ±cÄ± verilerini hazÄ±rla
                user_data = {
                    'id': user.id,
                    'username': user.username if user.username else None,
                    'first_name': user.first_name if hasattr(user, 'first_name') else None,
                    'last_name': user.last_name if hasattr(user, 'last_name') and user.last_name else None,
                    'phone': user.phone if hasattr(user, 'phone') and user.phone else None,
                    'group_id': group_id,
                    'group_title': entity.title if hasattr(entity, 'title') else "Bilinmeyen Grup",
                }
                users.append(user_data)
                
            logger.info(f"Toplam {len(users)} kullanÄ±cÄ± Ã§ekildi (grup: {group_id})")
            return users
            
        except errors.ChannelPrivateError:
            logger.warning(f"Grup {group_id} Ã¶zel bir kanal. KullanÄ±cÄ±lar Ã§ekilemiyor.")
            return []
            
        except errors.ChatAdminRequiredError:
            logger.warning(f"Grup {group_id} iÃ§in admin yetkileri gerekli.")
            return []
                    
            except Exception as e:
            logger.error(f"Grup kullanÄ±cÄ±larÄ± Ã§ekme hatasÄ±: {group_id} - {str(e)}")
            return []

    async def _send_message_to_group(self, group_id: Union[int, str], message_type: str = None) -> bool:
        """
        Belirtilen gruba mesaj gÃ¶nderir.
        
        :param group_id: Grubun ID'si (int veya str olabilir)
        :param message_type: GÃ¶nderilecek mesaj tÃ¼rÃ¼
        :return: Mesaj baÅŸarÄ±yla gÃ¶nderildi mi (boolean)
        """
        # Rate limit kontrolÃ¼
        if not self.rate_limiter.can_execute():
            wait_time = self.rate_limiter.get_wait_time()
            logger.warning(f"Rate limit aÅŸÄ±ldÄ±. {wait_time:.2f} saniye bekleniyor")
            return False
            
        # group_id kontrolÃ¼
        if group_id is None or (isinstance(group_id, str) and not group_id.strip()):
            logger.error("Grup ID'si None veya boÅŸ")
            return False
            
        # group_id'yi int'e Ã§evir (eÄŸer string ise)
        if isinstance(group_id, str):
            try:
                group_id = int(group_id)
            except ValueError:
                logger.error(f"GeÃ§ersiz grup ID formatÄ±: {group_id}")
                return False
                
        # Mesaj tÃ¼rÃ¼nÃ¼ seÃ§
        message_types = list(self.message_templates.keys())
        if not message_type or message_type not in message_types:
            message_type = random.choice(message_types)
            
        message_text = self.message_templates[message_type]
        
        logger.debug(f"Gruba mesaj gÃ¶nderiliyor: {group_id}, mesaj tÃ¼rÃ¼: {message_type}")
        
        try:
            # MesajÄ± gÃ¶nder
            await self.client.send_message(group_id, message_text)
            
            # BaÅŸarÄ± durumunu kaydet
            self.rate_limiter.mark_success()
            
            # VeritabanÄ±nÄ± gÃ¼ncelle
            async with aiosqlite.connect(self.db_path) as db:
                now = int(time.time())
                await db.execute(
                    "UPDATE groups SET last_message_time = ?, message_count = message_count + 1 WHERE group_id = ?",
                    (now, group_id)
                )
                await db.commit()
                
            logger.info(f"Mesaj baÅŸarÄ±yla gÃ¶nderildi: Grup {group_id}, TÃ¼r: {message_type}")
            return True
            
        except FloodWaitError as e:
            self.rate_limiter.register_error()
            wait_seconds = e.seconds
            
            # VeritabanÄ±nÄ± gÃ¼ncelle
            async with aiosqlite.connect(self.db_path) as db:
                await db.execute(
                    "UPDATE groups SET last_error = ?, retry_after = ? WHERE group_id = ?",
                    (f"FloodWaitError: {wait_seconds}s bekle", now + wait_seconds, group_id)
                )
                await db.commit()
                
            logger.warning(f"FloodWaitError: Grup {group_id} iÃ§in {wait_seconds} saniye beklenmeli")
            return False
            
        except ChannelPrivateError:
            self.rate_limiter.register_error()
            
            # VeritabanÄ±nÄ± gÃ¼ncelle
            async with aiosqlite.connect(self.db_path) as db:
                await db.execute(
                    "UPDATE groups SET active = 0, permanent_error = 'Kanal Ã¶zel', last_error = ? WHERE group_id = ?",
                    (f"ChannelPrivateError: Kanal Ã¶zel", group_id)
                )
                await db.commit()
                
            logger.warning(f"Grup {group_id} artÄ±k Ã¶zel veya eriÅŸilemez. Devre dÄ±ÅŸÄ± bÄ±rakÄ±ldÄ±.")
            return False
            
        except ChatWriteForbiddenError:
            self.rate_limiter.register_error()
            
            # VeritabanÄ±nÄ± gÃ¼ncelle
            async with aiosqlite.connect(self.db_path) as db:
                await db.execute(
                    "UPDATE groups SET active = 0, permanent_error = 'Yazma izni yok', last_error = ? WHERE group_id = ?",
                    (f"ChatWriteForbiddenError: Yazma izni yok", group_id)
                )
                await db.commit()
                
            logger.warning(f"Grup {group_id}'de yazma izni yok. Devre dÄ±ÅŸÄ± bÄ±rakÄ±ldÄ±.")
            return False
            
        except ChatAdminRequiredError:
            self.rate_limiter.register_error()
            
            # VeritabanÄ±nÄ± gÃ¼ncelle
            async with aiosqlite.connect(self.db_path) as db:
                await db.execute(
                    "UPDATE groups SET active = 0, permanent_error = 'Admin izni gerekli', last_error = ? WHERE group_id = ?",
                    (f"ChatAdminRequiredError: Admin izni gerekli", group_id)
                )
                await db.commit()
                
            logger.warning(f"Grup {group_id} iÃ§in admin izni gerekli. Devre dÄ±ÅŸÄ± bÄ±rakÄ±ldÄ±.")
            return False
            
                except Exception as e:
            self.rate_limiter.register_error()
            error_message = str(e)
            
            # VeritabanÄ±nÄ± gÃ¼ncelle
            async with aiosqlite.connect(self.db_path) as db:
                now = int(time.time())
                await db.execute(
                    "UPDATE groups SET last_error = ? WHERE group_id = ?",
                    (error_message[:100], group_id)  # Hata mesajÄ±nÄ± 100 karakter ile sÄ±nÄ±rla
                )
                await db.commit()
                
            logger.error(f"Grup {group_id}'e mesaj gÃ¶nderilirken hata oluÅŸtu: {error_message}")
            return False