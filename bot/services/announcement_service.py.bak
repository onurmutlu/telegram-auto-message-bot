"""
# ============================================================================ #
# Dosya: announcement_service.py
# Yol: /Users/siyahkare/code/telegram-bot/bot/services/announcement_service.py
# İşlev: Gruplarda duyuru ve tanıtım mesajları gönderimi.
#
# © 2025 SiyahKare Yazılım - Tüm Hakları Saklıdır
# ============================================================================ #
"""

import asyncio
import json
import logging
import os
import random
from datetime import datetime, timedelta
from typing import Dict, List, Any, Set, Optional, Tuple

from bot.services.base_service import BaseService
from bot.utils.adaptive_rate_limiter import AdaptiveRateLimiter
from telethon import errors

logger = logging.getLogger(__name__)

class AnnouncementService(BaseService):
    """
    Gruplarda duyuru ve tanıtım mesajları gönderimi yapan servis.
    
    Bu servis:
    1. Farklı grup kategorilerine göre özelleştirilmiş duyurular yapar
    2. Grup trafiğine göre akıllı mesaj gönderimleri yapar
    3. Kendi gruplarımızda düzenli tanıtımlar yapar
    4. Riskli gruplarda dikkatli ve seyrek mesaj gönderir
    
    Attributes:
        client: Telegram istemcisi
        config: Bot yapılandırma nesnesi
        db: Veritabanı nesnesi
        group_categories: Grup kategorileri
    """
    
    def __init__(self, client, config, db, stop_event=None):
        """
        AnnouncementService sınıfının başlatıcısı.
        
        Args:
            client: Telegram istemcisi
            config: Bot yapılandırma nesnesi
            db: Veritabanı nesnesi
            stop_event: Durdurma sinyali
        """
        super().__init__("announcement", client, config, db, stop_event)
        
        # Durum takibi
        self.running = False
        self.announcement_count = 0
        self.last_announcement_time = None
        
        # Grup kategorileri
        self.group_categories = {
            'own_groups': set(),     # Kendi gruplarımız
            'safe_groups': set(),    # Güvenli gruplar
            'risky_groups': set(),   # Riskli gruplar (dikkatli olunmalı)
            'high_traffic_groups': set(),  # Yüksek trafikli gruplar
        }
        
        # Grupların son mesaj zamanları
        self.last_group_message = {}
        
        # Mesajlar için rate_limiter
        self.rate_limiter = AdaptiveRateLimiter(
            initial_rate=10,  # Başlangıçta dakikada 10 mesaj (önceden 5 idi)
            period=20,       # 20 saniyelik periyot (önceden 30 idi)
            error_backoff=1.2, # Hata durumunda 1.2x yavaşlama (önceden 1.5 idi)
            max_jitter=1.0   # Maksimum 1 saniyelik rastgele gecikme (önceden 2.0 idi)
        )
        
        # Servisler
        self.services = {}
        
        # Ayarları yükle
        self._load_settings()
        self._load_templates()
        
        self.announcements = {}
        self.stats = {
            'total_sent': 0,
            'last_sent': None
        }
    
    def _load_settings(self):
        """Duyuru servisi ayarlarını yükler."""
        # Yapılandırma dosyasından veya çevre değişkenlerinden
        self.announcement_interval_minutes = self.config.get_setting('announcement_interval_minutes', 30) # Önceden 60 idi
        
        # Grup kategorilerine göre gönderim aralıkları (saat)
        self.cooldown_hours = {
            'own_groups': 0.25,        # Kendi gruplarımızda çok sık mesaj (önceden 0.5 idi)
            'safe_groups': 1,         # Güvenli gruplarda sık mesaj (önceden 2 idi)
            'risky_groups': 3,        # Riskli gruplarda nadir (önceden 6 idi)
            'high_traffic_groups': 1.5  # Yüksek trafikli gruplarda orta sıklıkta (önceden 3 idi)
        }
        
        # Kendi gruplarımızı yükle
        own_groups = os.getenv("GROUP_LINKS", "").split(',')
        self.own_groups = [g.strip() for g in own_groups if g.strip()]
        
        # Grup kategorileri için batchler
        self.batch_size = {
            'own_groups': 10,           # Kendi gruplarımızın hepsine (önceden 5 idi)
            'safe_groups': 15,          # Güvenli gruplara toplu (önceden 8 idi)
            'risky_groups': 5,         # Riskli gruplara tek tek (önceden 2 idi)
            'high_traffic_groups': 10   # Yüksek trafikli gruplara orta batch (önceden 5 idi)
        }
        
        self.debug = self.config.get_setting('debug', False)
        
        logger.info("Duyuru servisi ayarları yüklendi")
    
    def _load_templates(self):
        """Duyuru mesaj şablonlarını yükler."""
        try:
            # Şablon dosyası
            with open('data/announcements.json', 'r', encoding='utf-8') as f:
                data = json.load(f)
            
            # Şablon formatını kontrol et ve yapılandır
            if isinstance(data, dict):
                # Yeni format - ID'ye göre şablonlar
                self.announcement_templates = {}
                
                # Şablonları grup tipine göre kategorize et
                for template_id, template_info in data.items():
                    if isinstance(template_info, dict) and "group_type" in template_info:
                        group_type = template_info["group_type"]
                        category = template_info.get("category", "general")
                        
                        # Gerekirse grup tipine ait sözlüğü oluştur
                        if group_type not in self.announcement_templates:
                            self.announcement_templates[group_type] = {}
                        
                        # Gerekirse kategoriye ait listeyi oluştur
                        if category not in self.announcement_templates[group_type]:
                            self.announcement_templates[group_type][category] = []
                        
                        # Şablonu ekle
                        self.announcement_templates[group_type][category].append(template_info["content"])
                        
                # Log şablon sayılarını
                for group_type, categories in self.announcement_templates.items():
                    for category, templates in categories.items():
                        logger.debug(f"{group_type} - {category}: {len(templates)} şablon")
            else:
                logger.warning("Geçersiz şablon formatı! Sözlük formatı bekleniyor")
                self.announcement_templates = {
                    "own_groups": {
                        "promotion": ["Grubumuzun yeni özelliklerini denediniz mi? t.me/{}"]
                    }
                }
                
        except Exception as e:
            logger.error(f"Duyuru şablonları yüklenirken hata: {str(e)}")
            # Basit varsayılan şablon
            self.announcement_templates = {
                "own_groups": {
                    "promotion": ["Grubumuzun yeni özelliklerini denediniz mi? t.me/{}"]
                }
            }
    
    async def initialize(self) -> bool:
        """
        Servisi başlatır ve verileri yükler.
        
        Returns:
            bool: Başarılı ise True
        """
        # Temel servisi başlat
        await super().initialize()
        
        # Grupları kategorilere ayır
        await self._categorize_groups()
        
        logger.info(f"Duyuru servisi başlatıldı")
        return True
    
    async def _categorize_groups(self):
        """Grupları kategorilere ayırır."""
        try:
            # Grup kategorilerini sıfırla
            for category in self.group_categories:
                self.group_categories[category] = set()
                
            # Veritabanından tüm grupları al
            all_groups = await self._get_all_groups()
                
            if not all_groups:
                logger.warning("Veritabanında grup bulunamadı!")
                return
            
            # Grupları kategorilere ayır
            for group in all_groups:
                group_id = group.get('group_id')
                username = group.get('username', '')
                name = group.get('name', '')
                member_count = group.get('member_count', 0)
                is_public = group.get('is_public', False)
                can_send_messages = group.get('can_send_messages', False)
                
                # Mesaj gönderilemeyen grupları atla
                if not can_send_messages:
                    continue
                
                # 1. Kendi gruplarımız
                if username in self.own_groups or any(own in name.lower() for own in self.own_groups):
                    self.group_categories['own_groups'].add(group_id)
                    continue
                
                # 2. Güvenli gruplar (çeşitli kriterlere göre)
                if is_public and member_count > 500:
                    self.group_categories['safe_groups'].add(group_id)
                    continue
                
                # 3. Yüksek trafikli gruplar
                if member_count > 1000:
                    self.group_categories['high_traffic_groups'].add(group_id)
                    continue
                
                # 4. Geriye kalanlar riskli gruplar
                self.group_categories['risky_groups'].add(group_id)
                
            # Log kategorileri
            for category, groups in self.group_categories.items():
                logger.info(f"{category}: {len(groups)} grup")
                
        except Exception as e:
            logger.error(f"Grupları kategorilere ayırırken hata: {str(e)}")
    
    async def _get_all_groups(self):
        """
        Tüm grupları getirir.
        
        Returns:
            List[Dict]: Grup listesi
        """
        try:
            # Önce veritabanından grupları almaya çalış
            if hasattr(self.db, 'get_all_groups'):
                try:
                    groups = await self.db.get_all_groups()  # await kullanımı
                    if groups:
                        return groups  # direkt objeyi dön
                except Exception as e:
                    logger.error(f"get_all_groups hatası: {str(e)}")
            
            # Veritabanında metod yoksa diğer alternatifleri dene
            if hasattr(self.db, 'get_groups'):
                try:
                    groups = await self._run_async_db_method(self.db.get_groups)
                    if groups:
                        return groups
                except Exception as e:
                    logger.error(f"get_groups hatası: {str(e)}")
            
            # Diğer alternatifler...
            # Hala grup bulunamadıysa, grupları keşfet
            logger.info("Veritabanında grup bulunamadı. Grupları keşfetmeye çalışıyorum.")
            
            # Grup servisine erişim varsa keşif yap
            if hasattr(self, 'services') and 'group' in self.services:
                try:
                    group_service = self.services['group']
                    await group_service.discover_groups()
                    # Keşif sonrası grupları tekrar almayı dene
                    if hasattr(self.db, 'get_all_groups'):
                        groups = await self.db.get_all_groups()
                        if groups:
                            logger.info(f"Grup keşfi sonrası {len(groups)} grup bulundu.")
                            return groups
                except Exception as e:
                    logger.error(f"Grup keşfi hatası: {str(e)}")
            
            # Gruplar hala bulunamadıysa, manuel olarak keşfet
            try:
                # Dialog'lardan grupları al
                groups = []
                async for dialog in self.client.iter_dialogs():
                    if dialog.is_group or dialog.is_channel:
                        entity = dialog.entity
                        group_id = entity.id
                        title = entity.title
                        username = getattr(entity, 'username', None)
                        
                        # Grubu kaydet
                        if hasattr(self.db, 'add_group'):
                            await self._run_async_db_method(
                                self.db.add_group,
                                group_id,
                                title,
                                username=username
                            )
                        
                        # Sonuç listesine ekle
                        groups.append({
                            'group_id': group_id,
                            'name': title,
                            'username': username,
                            'is_public': username is not None,
                            'can_send_messages': True
                        })
                
                if groups:
                    logger.info(f"Manuel keşif sonrası {len(groups)} grup bulundu.")
                    return groups
            except Exception as e:
                logger.error(f"Manuel grup keşfi hatası: {str(e)}")
            
            # Hiçbir şekilde grup bulunamazsa boş liste döndür
            return []
            
        except Exception as e:
            logger.error(f"Grupları alma hatası: {str(e)}")
            return []

    async def categorize_groups(self, groups):
        """
        Grupları kategorilere ayırır.
        """
        try:
            # groups bir coroutine değil, bir liste olmalı
            if not isinstance(groups, list):
                logger.warning("Gruplar için geçersiz tip, boş liste kullanılıyor")
                groups = []
                
            # Boş kategoriler oluştur
            categories = {
                'large': [],
                'medium': [],
                'small': []
            }
            
            # Grupları üye sayılarına göre kategorize et
            for group in groups:
                member_count = group.get('members_count', 0)
                
                if member_count > 500:
                    categories['large'].append(group)
                elif member_count > 100:
                    categories['medium'].append(group)
                else:
                    categories['small'].append(group)
                    
            return categories
            
        except Exception as e:
            logger.error(f"Grupları kategorilere ayırırken hata: {str(e)}")
            return {'large': [], 'medium': [], 'small': []}
    
    async def start(self) -> bool:
        """
        Servisi başlatır.
        
        Returns:
            bool: Başarılı ise True
        """
        if not self.initialized:
            await self.initialize()
            
        self.running = True
        self.start_time = datetime.now()
        logger.info(f"{self.service_name} servisi başlatıldı.")
        return True
    
    async def stop(self) -> None:
        """
        Servisi güvenli bir şekilde durdurur.
        
        Returns:
            None
        """
        # Önce durum değişkenini güncelle
        self.running = False
        
        # Durdurma sinyalini ayarla (varsa)
        if hasattr(self, 'stop_event') and self.stop_event:
            self.stop_event.set()
            
        # Diğer durdurma sinyallerini de kontrol et
        if hasattr(self, 'shutdown_event'):
            self.shutdown_event.set()
        
        # Çalışan görevleri iptal et
        try:
            service_tasks = [task for task in asyncio.all_tasks() 
                        if (task.get_name().startswith(f"{self.name}_task_") or
                            task.get_name().startswith(f"{self.service_name}_task_")) and 
                        not task.done() and not task.cancelled()]
                        
            for task in service_tasks:
                task.cancel()
                
            # Kısa bir süre bekle
            try:
                await asyncio.sleep(0.5)
            except asyncio.CancelledError:
                pass
                
            # İptal edilen görevlerin tamamlanmasını kontrol et
            if service_tasks:
                await asyncio.wait(service_tasks, timeout=2.0)
        except Exception as e:
            logger.error(f"{self.service_name} görevleri iptal edilirken hata: {str(e)}")
            
        logger.info(f"{self.service_name} servisi durduruldu.")
    
    async def _announcement_loop(self):
        """Periyodik duyuru gönderimlerini yönetir."""
        logger.info("Duyuru döngüsü başlatıldı")
        
        while self.running and not self.stop_event.is_set():
            try:
                # Her kategori için bir turda bir grup seçip mesaj gönder
                for category, groups in self.group_categories.items():
                    if not groups:
                        continue
                        
                    # Bu kategoriden kaç gruba mesaj göndereceğiz? (Artırıldı)
                    batch_count = min(self.batch_size.get(category, 3), len(groups))
                    
                    # Gruba göre duyuru türü seç (promotion, services, showcase, ads)
                    announcement_type = random.choice(['promotion', 'services', 'showcase', 'ads'])
                    
                    # Bu kategoriden uygun grupları seç
                    eligible_groups = await self._get_eligible_groups(category)
                    if not eligible_groups:
                        logger.debug(f"{category} kategorisinde uygun grup bulunamadı")
                        continue
                        
                    # Batch'ten fazla grup varsa random örneklem al (Artırıldı)
                    selected_groups = random.sample(eligible_groups, min(batch_count, len(eligible_groups)))
                    
                    # Seçilen gruplara mesaj gönder
                    for group_id in selected_groups:
                        success = await self._send_announcement_to_group(group_id, category, announcement_type)
                        if success:
                            self.last_group_message[group_id] = datetime.now()
                            self.announcement_count += 1
                            
                        # Her mesaj arasında çok az bekle (Daha da kısaltıldı)
                        await asyncio.sleep(0.2 + random.random() * 0.5)
                
                # Bir sonraki tura kadar bekle (Daha da kısaltıldı)
                interval = (self.announcement_interval_minutes * 60) / 8  # Sekizde bir süre
                logger.debug(f"Bir sonraki duyuru turu için {interval} saniye bekleniyor")
                await asyncio.sleep(interval)
                
            except asyncio.CancelledError:
                logger.info("Duyuru döngüsü iptal edildi")
                break
            except Exception as e:
                logger.error(f"Duyuru döngüsünde hata: {str(e)}")
                await asyncio.sleep(60)  # Hata durumunda 1 dakika bekle (Kısaltıldı)
    
    async def _get_eligible_groups(self, category: str) -> List[int]:
        """
        Mesaj gönderilebilecek uygun grupları belirler.
        
        Args:
            category: Grup kategorisi
            
        Returns:
            List[int]: Uygun grup ID'leri
        """
        eligible_groups = []
        now = datetime.now()
        # Cooldown süresini azaltalım (kaç saat bekleneceği)
        cooldown_hours = self.cooldown_hours.get(category, 3)  # 6'dan 3'e düşürüldü
        
        for group_id in self.group_categories[category]:
            # Bu gruba en son ne zaman mesaj gönderdik?
            last_msg_time = self.last_group_message.get(group_id)
            
            # Hiç gönderilmemişse veya cooldown süresi geçmişse
            if not last_msg_time or (now - last_msg_time) >= timedelta(hours=cooldown_hours):
                eligible_groups.append(group_id)
        
        return eligible_groups
    
    async def _send_announcement_to_group(self, group_id: int, category: str, announcement_type: str) -> bool:
        """
        Belirli bir gruba duyuru gönderir.
        
        Args:
            group_id: Duyuru gönderilecek grubun ID'si
            category: Grup kategorisi
            announcement_type: Duyuru tipi
            
        Returns:
            bool: Başarılı ise True
        """
        try:
            # 1. Güvenlik kontrolü yap - cooldown süresini azalt
            if group_id in self.last_group_message:
                last_time = self.last_group_message[group_id]
                hours_since_last = (datetime.now() - last_time).total_seconds() / 3600
                
                # Cooldown süresini kategoriye göre azalt
                if hours_since_last < self.cooldown_hours.get(category, 12):  # 24'ten 12'ye düşürüldü
                    logger.debug(f"Grup {group_id} için bekletme süresi dolmadı: Son mesajdan {hours_since_last:.1f} saat geçmiş")
                    return False
            
            # 2. Grup güvenliğini kontrol et (GroupService varsa)
            is_safe = True
            if 'group' in self.services and hasattr(self.services['group'], 'analyze_group_safety'):
                try:
                    safety_result = await self.services['group'].analyze_group_safety(group_id)
                    is_safe = safety_result.get('is_safe', True)
                    
                    if not is_safe:
                        risk_level = safety_result.get('risk_level', 'high')
                        logger.warning(f"Grup güvenli değil (risk: {risk_level}), duyuru gönderilmiyor: {group_id}")
                        return False
                except Exception as safety_error:
                    logger.error(f"Grup güvenlik analizi hatası: {str(safety_error)}")
            
            # 3. Mesaj içeriğini seç
            message = self._choose_announcement_template(category, announcement_type)
            if not message:
                logger.warning(f"Uygun duyuru şablonu bulunamadı: {category}/{announcement_type}")
                return False
            
            # 4. Varsa kendi grup linklerimizi mesaja ekle
            own_links = self._parse_group_links()
            if own_links and '{}' in message:
                link = random.choice(own_links)
                message = message.format(link)
            
            # 5. Hız kontrolü - FloodWait hatalarını önlemek için
            wait_time = self.rate_limiter.get_wait_time()
            if wait_time > 0:
                logger.debug(f"Hız limiti nedeniyle {wait_time:.1f} sn bekleniyor")
                await asyncio.sleep(wait_time)
            
            # 6. Mesajı gönder - güvenli hata yakalama ile 
            max_retries = 2
            retry_count = 0
            last_error = None
            
            while retry_count <= max_retries:
                try:
                    # DataMining servisini kullan (varsa) entity alma
                    entity = None
                    
                    if 'dm' in self.services and hasattr(self.services['dm'], 'get_safe_entity'):
                        entity = await self.services['dm'].get_safe_entity(group_id) 
                    
                    # Entity bulunamadıysa doğrudan ID ile dene
                    if entity:
                        await self.client.send_message(entity, message)
                    else:
                        await self.client.send_message(group_id, message)
                    
                    # Başarılı gönderim
                    self.last_group_message[group_id] = datetime.now()
                    self.announcement_count += 1
                    self.last_announcement_time = datetime.now()
                    
                    # Başarıyı rate_limiter'a bildir
                    self.rate_limiter.mark_success()
                    
                    logger.info(f"Duyuru gönderildi: Grup {group_id}, Tip {announcement_type}")
                    return True
                    
                except errors.FloodWaitError as e:
                    # Rate limit hatası
                    wait_seconds = e.seconds
                    logger.warning(f"FloodWait hatası: {wait_seconds} saniye bekleniyor")
                    
                    # Rate limiter'ı güncelle
                    self.rate_limiter.register_error(e)
                    
                    # Bekleme süresini ayarla
                    await asyncio.sleep(wait_seconds + 1)
                    retry_count += 1
                    last_error = e
                    
                except (errors.ChatWriteForbiddenError, errors.ChatAdminRequiredError) as e:
                    # Kalıcı hata - bu gruba bir daha mesaj göndermeye çalışma
                    logger.warning(f"Gruba yazma izni yok: {group_id}, {str(e)}")
                    
                    # Grup servisine hatayı raporla
                    if 'group' in self.services and hasattr(self.services['group'], '_update_group_error'):
                        await self.services['group']._update_group_error(
                            group_id, 
                            f"ChatWriteForbiddenError: {str(e)}", 
                            permanent=True
                        )
                    
                    return False
                    
                except Exception as e:
                    # Diğer hatalar için tekrar dene
                    logger.error(f"Duyuru gönderirken hata: {str(e)}")
                    retry_count += 1
                    last_error = e
                    
                    # Kısa bekleyip tekrar dene
                    await asyncio.sleep(2 * retry_count)
            
            # Tüm denemeler başarısız oldu
            error_type = type(last_error).__name__ if last_error else "Unknown"
            logger.error(f"Maksimum deneme sayısı aşıldı, duyuru gönderilemedi: {group_id} (Hata: {error_type})")
            
            # Rate limiter'a hatayı bildir
            self.rate_limiter.register_failure()
            
            return False
            
        except Exception as e:
            logger.error(f"Duyuru gönderme işlemi başarısız: {str(e)}")
            return False
    
    def _choose_announcement_template(self, category: str, announcement_type: str) -> str:
        """
        Belirtilen kategori ve tür için bir duyuru şablonu seçer.
        
        Args:
            category: Grup kategorisi
            announcement_type: Duyuru türü
            
        Returns:
            str: Şablon metni veya None
        """
        try:
            # Kategori için şablonlar var mı?
            if category not in self.announcement_templates:
                category = "own_groups"  # Fallback to default
            
            category_templates = self.announcement_templates[category]
            
            # Türe göre şablonlar var mı?
            if announcement_type not in category_templates:
                announcement_type = "promotion"  # Fallback to default
            
            templates = category_templates[announcement_type]
            
            if templates:
                return random.choice(templates)
            else:
                return None
                
        except Exception as e:
            logger.error(f"Şablon seçme hatası: {str(e)}")
            return None
            
    def _parse_group_links(self) -> List[str]:
        """Grup linklerini çevre değişkenlerinden veya yapılandırmadan yükler."""
        # Çevre değişkeninden deneyelim
        links_str = os.getenv("GROUP_LINKS", "")
        
        # Virgülle ayrılmış değerleri dizi haline getir
        links = [link.strip() for link in links_str.split(',') if link.strip()]
        
        # Bağlantı yoksa fallback
        if not links:
            links = ["arayisplatin"]
        
        return links
    
    def set_services(self, services):
        """
        Diğer servislere referansları ayarlar.
        
        Args:
            services: Servis adı -> servis nesnesi eşleşmesi
        """
        self.services = services
        logger.debug(f"Duyuru servisi diğer servislere bağlandı")
    
    async def send_custom_announcement(self, message: str, category: str = None, group_ids: List[int] = None) -> int:
        """
        Özel bir duyuru mesajı gönderir.
        
        Args:
            message: Gönderilecek mesaj
            category: Hedef grup kategorisi (belirtilmezse tüm kategoriler)
            group_ids: Belirli grup ID'leri (belirtilmezse kategoriye göre)
            
        Returns:
            int: Başarıyla gönderilen mesaj sayısı
        """
        target_groups = []
        
        # Hedef grupları belirle
        if group_ids:
            target_groups = group_ids
        elif category and category in self.group_categories:
            target_groups = list(self.group_categories[category])
        else:
            # Tüm kategorilerden grupları al
            for groups in self.group_categories.values():
                target_groups.extend(groups)
                
        if not target_groups:
            logger.warning("Özel duyuru için hedef grup bulunamadı")
            return 0
        
        # Mesajları gönder
        sent_count = 0
        for group_id in target_groups:
            try:
                # Hız sınırı kontrolü
                wait_time = self.rate_limiter.get_wait_time()
                if wait_time > 0:
                    await asyncio.sleep(wait_time)
                    
                await self.client.send_message(group_id, message)
                self.rate_limiter.mark_used()
                sent_count += 1
                
                # Son mesaj zamanını güncelle
                self.last_group_message[group_id] = datetime.now()
                
                # Kısa bir bekleme
                await asyncio.sleep(1 + random.random() * 2)
                
            except Exception as e:
                logger.error(f"Özel duyuru gönderirken hata (Grup {group_id}): {str(e)}")
                self.rate_limiter.register_error(e)
                
        logger.info(f"Özel duyuru gönderimi tamamlandı: {sent_count}/{len(target_groups)} başarılı")
        return sent_count
    
    async def get_status(self) -> Dict[str, Any]:
        """
        Servisin mevcut durumunu döndürür.
        
        Returns:
            Dict: Servis durum bilgileri
        """
        status = await super().get_status()
        
        # Grup kategorilerini say
        categories_count = {
            category: len(groups)
            for category, groups in self.group_categories.items()
        }
        
        status.update({
            'announcement_count': self.announcement_count,
            'last_announcement': self.last_announcement_time.strftime('%Y-%m-%d %H:%M:%S') if self.last_announcement_time else None,
            'group_categories': categories_count
        })
        
        return status
    
    async def get_statistics(self) -> Dict[str, Any]:
        """
        Servis istatistiklerini döndürür.
        
        Returns:
            Dict: Servis istatistikleri
        """
        return {
            'total_sent': self.announcement_count,
            'categories': {
                category: len(groups)
                for category, groups in self.group_categories.items()
            }
        }
    
    async def _run_async_db_method(self, method, *args, **kwargs):
        """Veritabanı metodunu thread-safe biçimde çalıştırır."""
        loop = asyncio.get_event_loop()
        return await loop.run_in_executor(
            None, 
            lambda: method(*args, **kwargs)
        )
    
    async def run(self):
        """Duyuru servisi için ana döngü."""
        logger.info("Duyuru servisi çalışıyor...")
        while self.running and not self.stop_event.is_set():
            try:
                # Duyuru işlemlerini belirli aralıklarla yap
                await asyncio.sleep(60)  # 1 dakika bekle
                # Burada duyuru gönderimi için gerekli işlemleri yapabilirsiniz
            except asyncio.CancelledError:
                logger.info("Duyuru servis döngüsü iptal edildi")
                break
            except Exception as e:
                logger.error(f"Duyuru servisi çalışırken hata: {str(e)}")
        
        logger.info("Duyuru servis döngüsü sonlandı")